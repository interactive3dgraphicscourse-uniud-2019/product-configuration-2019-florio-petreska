<head><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/><link rel="stylesheet" href="/css/main.css"/><script src="./js/lib/three.min.js"></script><script src="./js/lib/stats.min.js"></script><script src="./js/lib/OrbitControls.js"></script><script src="./js/lib/LoaderSupport.js"></script><script src="./js/lib/OBJLoader2.js"></script><script src="./js/lib/BufferGeometryUtils.js"></script></head><body><script type="text/x-glsl" id="vertex">varying vec3 vNormal;		
varying vec3 vPosition;
void main() {
vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
vPosition = vPos.xyz;
vNormal = normalMatrix * normal;
gl_Position = projectionMatrix * vPos;
}
</script><script type="text/x-glsl" id="fragment">varying vec3 vNormal;
varying vec3 vPosition;
uniform vec3 pointLightsPosition[3]; // in world space
uniform vec3 clight;
uniform vec3 c;
uniform float metalness;
uniform float roughness;
uniform vec3 ambientLight;
const float PI = 3.14159;
const int numberOfLights = 3;

vec3 FSchlick(float lDoth) {
	return (vec3(max(metalness, 0.04))*c + (vec3(1.0)-vec3(max(metalness, 0.04))*c)*pow(1.0 - lDoth,5.0));
}
float DGGX(float nDoth, float alpha) {
	float alpha2 = alpha*alpha;
	float d = nDoth*nDoth*(alpha2-1.0)+1.0;
	return (  alpha2 / (PI*d*d));
}
float G1(float dotProduct, float k) {
	return (dotProduct / (dotProduct*(1.0-k) + k) );
}
float GSmith(float nDotv, float nDotl) {
		float k = roughness*roughness;
		return G1(nDotl,k)*G1(nDotv,k);
}


void main() {
	
	vec3 outRadiance[numberOfLights];
	for(int i=0; i<numberOfLights; i++) {
		vec4 lPosition = viewMatrix * vec4( pointLightsPosition[i], 1.0 );
		vec3 l = normalize(lPosition.xyz - vPosition.xyz);
		vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
		vec3 v = normalize( -vPosition);
		vec3 h = normalize( v + l);
		// small quantity to prevent divisions by 0
		float nDotl = max(dot( n, l ),0.000001);
		float lDoth = max(dot( l, h ),0.000001);
		float nDoth = max(dot( n, h ),0.000001);
		float vDoth = max(dot( v, h ),0.000001);
		float nDotv = max(dot( n, v ),0.000001);
		vec3 fresnel = FSchlick(lDoth);
		vec3 BRDF = vec3(1.0-metalness)*c/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness) / (4.0*nDotl*nDotv);
		outRadiance[i] = PI* clight * nDotl * BRDF;
	}

	vec3 outRadianceF;
	for(int i=0; i<numberOfLights; i++) {
		outRadianceF = outRadianceF + outRadiance[i];
	}

	outRadianceF = outRadianceF + ambientLight * c;

	// gamma encode the final value
	gl_FragColor = vec4(pow( outRadianceF, vec3(1.0/2.2)), 1.0);
}
</script><script type="text/x-glsl" id="vertex-textures">attribute vec4 tangent;
varying vec3 vNormal;
varying vec3 vPosition;
varying vec2 uVv;
varying vec3 vTangent;
varying vec3 vBitangent;
void main() {
	vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
	vPosition = vPos.xyz;
	vNormal = normalMatrix * normal;
	vec3 objectTangent = vec3( tangent.xyz );
	vec3 transformedTangent = normalMatrix * objectTangent;
	vTangent = normalize( transformedTangent );
	vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	uVv = uv; // uv variabile pre calcolata dal software (derivata dal modello)
	gl_Position = projectionMatrix * vPos;

}
</script><script type="text/x-glsl" id="fragment-textures">varying vec3 vNormal;
	varying vec3 vPosition;
	varying vec2 uVv;
	varying vec3 vTangent;
	varying vec3 vBitangent;
	uniform vec3 pointLightsPosition[3]; // in world space
	uniform vec3 clight;
	// immagini
	uniform sampler2D specularMap;
	uniform sampler2D diffuseMap;
	uniform sampler2D roughnessMap;
	uniform sampler2D normalMap;
	uniform vec2 textureRepeat; // valore del repeat in 2D
	uniform sampler2D aoMap;
	uniform vec3 ambientLight;

	vec3 metalness;
	const float PI = 3.14159;
	const int numberOfLights = 3;
	vec3 cdiff;
	vec3 cspec;
	float roughness;
	vec3 FSchlick(float lDoth) {
		return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
	}
	float DGGX(float nDoth, float alpha) {
		float alpha2 = alpha*alpha;
		float d = nDoth*nDoth*(alpha2-1.0)+1.0;
		return (  alpha2 / (PI*d*d));
	}
	float G1(float dotProduct, float k) {
		return (dotProduct / (dotProduct*(1.0-k) + k) );
	}
	float GSmith(float nDotv, float nDotl) {
			float k = roughness*roughness;
			return G1(nDotl,k)*G1(nDotv,k);
	}
	void main() {
		vec3 outRadiance[numberOfLights];
		vec3 outRadianceF;
		
		for(int i=0; i<numberOfLights; i++) {
			metalness = pow(texture2D( specularMap, uVv*textureRepeat ).rgb, vec3(2.2));
			vec4 lPosition = viewMatrix * vec4( pointLightsPosition[i], 1.0 );
			vec3 l = normalize(lPosition.xyz - vPosition.xyz);
			vec3 normal = normalize( vNormal );
			vec3 tangent = normalize( vTangent );
			vec3 bitangent = normalize( vBitangent );
			mat3 vTBN = mat3( tangent, bitangent, normal );
			vec3 mapN = texture2D( normalMap, uVv * textureRepeat ).xyz * 2.0 - 1.0; // inverso di +1; /2, prendo il valore corretto della normal map
			//mapN.xy = normalScale * mapN.xy; // contributo della perturbazione (quanto influisce sulla normale)
			vec3 n = normalize( vTBN * mapN );
			//vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
			vec3 v = normalize( -vPosition);
			vec3 h = normalize( v + l);
			// small quantity to prevent divisions by 0
			float nDotl = max(dot( n, l ),0.000001);
			float lDoth = max(dot( l, h ),0.000001);
			float nDoth = max(dot( n, h ),0.000001);
			float vDoth = max(dot( v, h ),0.000001);
			float nDotv = max(dot( n, v ),0.000001);
			cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb; // uVv*textureRepeat: prendo il punto corretto
			// texture in sRGB, linearize
			cdiff = pow( cdiff, vec3(2.2));
			//cspec = texture2D( specularMap, uVv*textureRepeat ).rgb * cdiff;
			// texture in sRGB, linearize
			//cspec = pow( cspec, vec3(2.2)) * cdiff;
			cspec = metalness * cdiff;
			roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map
			vec3 fresnel = FSchlick(lDoth);
			vec3 BRDF = (vec3(1.0)-metalness)*cdiff/PI + fresnel*GSmith(nDotv,nDotl)*DGGX(nDoth,roughness*roughness)/
				(4.0*nDotl*nDotv);
			outRadiance[i] = PI* clight * nDotl * BRDF;
		}

		
		for(int i=0; i<numberOfLights; i++) {
		 	outRadianceF = outRadianceF + outRadiance[i];
		 }

		outRadianceF = outRadianceF + ambientLight*cdiff*texture2D( aoMap, uVv*textureRepeat ).xyz;
		

		// gamma encode the final value
		gl_FragColor = vec4(pow( outRadianceF, vec3(1.0/2.2)), 1.0);	
	}
</script><div class="navbar-fixed"><nav><div class="nav-wrapper"><a class="brand-logo" href="#!"><img class="responsive-img" src="images/logo.png" alt="ACME"/></a><ul class="right hide-on-med-and-down"><li><a href="#">About</a></li><li><a href="#">Shop</a></li><li><a href="#">Help</a></li><li><a class="btn">Shopping Cart</a></li></ul></div></nav></div><div class="main"><div class="row configurator">  <div class="row title"><div class="pad"><h3>ACMEpad</h3></div><div class="reviews"><h6>5 Reviews <span class="fa fa-star checked" style="color:gold"></span>
<span class="fa fa-star checked" style="color:gold"></span>
<span class="fa fa-star checked" style="color:gold"></span>
<span class="fa fa-star checked" style="color:gold"></span>
<span class="fa fa-star-half-full" style="color:gold"></span></h6></div></div><div class="col m8 s12 object"><div id="threejs-container"></div></div><div class="col m4 s12 prop"><div class="row prop-title"><h6>FRONT <span>Silver</span></h6></div><div class="row prop-images"><div class="col s3 selection active" data-value="f-01"><img class="responsive-img" src="/images/f-01.png" alt="Black"/></div><div class="col s3 selection" data-value="f-02"><img class="responsive-img" src="/images/f-02.png" alt="White"/></div><div class="col s3 selection" data-value="f-03"><img class="responsive-img" src="/images/f-03.png" alt="Acme"/></div></div><div class="row prop-title"><h6>BACK <span>Leather</span></h6></div><div class="row prop-images"><div class="col s3 selection active" data-value="b-01"><img class="responsive-img" src="/images/b-01.png" alt="Gold"/></div><div class="col s3 selection" data-value="b-02"><img class="responsive-img" src="/images/b-02.png" alt="Rose Gold"/></div><div class="col s3 selection" data-value="b-03"><img class="responsive-img" src="/images/b-03.png" alt="Matte Black"/></div></div><div class="row prop-text"><p>Extraordinary performance, personalised design and immersive display, all packed together in ACMEpad that follows your own style.</p><p>With its battery capacity of 36.71Wh that lasts up to 15 hours, you can enjoy playing your augmented reality games on-the-go, thanks to the A12X Bionic chip.</p><p>Take it everywhere you go and show everybody your ultra lightweight, personalised ACMEpad.</p></div><div class="row cart valign-wrapper"><div class="col s6"><h5 class="price">$1200</h5></div><div class="col s6"><a class="btn">Add to cart</a></div></div></div></div></div><script src="./js/Tablet.js"></script><script src="./js/main.js"></script></body>